\section{Conclusion}
The goal of this project was to look into the reference implementation of the Rainbow scheme, port it to RISC-V and see if some aspects could be optimized. As the reference implementation offers multiple variants of the Rainbow scheme, each with multiple security levels, the standard variant of Rainbow level I was chosen. Trying to optimize the other two variants of Rainbow is not impossible, though would start to push the required memory sizes of the embedded device, which is quite an important aspect to take into account when working with embedded devices.
\medskip\\
The embedded platform, the PQVexRiscV CPU, used in this project is a less powerful type of embedded device when compared to some of the more mainstream ARM processors. The platform is also not as well-supported in terms of relevant libraries (for this project specifically, it might very well be for others). In total the platform is constrained to a degree for which the expectations were not to obtain a tremendously fast optimization, though to obtain some results that can be developed upon for further use. For this reason as well, the project itself is situated in an open (or at least going to be open) github repository available for further developments.
\medskip\\
As was shown in \cref{evalsec}, the speeds of the optimizations were to a degree where \emph{optimization} might be a far-fetched statement. The bitsliced implementation constructed for this project were about 3300\% slower than the standard implementation when ported. On the other hand, the lookup table implementation made for this project obtains only around 1.17\% slowdown when compared to the standard, ported, reference. The latter of the two optimization schemes were also the one closest to the reference implementation in terms of computational scheme. The lookup table implementation only replaces $GF(16)$ multiplications, whereas the bitsliced implementation replaces the whole public map computation of the scheme using a, possibly, naive way of computing it. In \cref{implementation:ffa}, referring to \cite{rainbownist}, it was stated that the computational scheme for computing the public map originally was the scheme due to Tung Chou which seeks to minimize the multiplications of finite field elements, which typically is also the more expensive of addition and multiplication.
\medskip\\
As the bitsliced optimization scheme is platform-independent and very abstracted, any further developments on trying to improve the scheme itself should not be hard as long as they follow the general structure of the code. If it is found that the scheme itself is very poorly thought out, then a total revision would be possible, potentially including some RISC-V assembly and more \texttt{c}-specific optimizations. As could be seen in \cref{bitslice:theory} the idea of bitslicing itself on a theoretical plan should be able to at least obtain the same speed as the ported reference implementation. Taking into account that the Rainbow verification scheme heavily uses finite field arithmetic, for good reason, the emphasis on the programmer-induced error in the current bitslicing scheme is heavily enforced. An interesting sidenote would be the overall cycle per instruction ratio that, if not a coincidence, could yield interesting results on the speed of the overall scheme.
\medskip\\
However, due to a limited scope, with regard to both time and complexity, any conclusive answers on the \emph{correct} nature of a bitslicing approach for this RISC-V platform cannot be provided as much time went into understanding, porting and trying to optimize the reference code. For the same reason, any further developments on expanding the research that went into optimization through lookup tables were also rather limited. One thing that this project clearly did bring was a ported RISC-V reference implementation that stands very close to the original non-ported version.
\pagebreak