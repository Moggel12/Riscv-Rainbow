\section{Preliminaries}
In subsection \ref{rainscheme} a general overview of the Rainbow Signature scheme, and the necessary theory and terminology, is given. In subection \ref{pre-riscv} we seek to briefly explain the nature of Reduced Instruction Set Computers and the processing utility used for running this project.
\subsection{The Rainbow scheme} \label{rainscheme}
The Rainbow cryptographic scheme is a multivariate public key cryptosystem (MKPC) that stands as a round 3 candidate in the NIST post-quantum standardization for signature schemes. Being an MKPC, a central aspect of Rainbow is the $NP$-completeness of solving multivariate polynomial systems, or more specifically multivariate quadratic, $MQ$, systems which is given as the NP-hard MQ-problem. [Multivariate public key cryptosystem chapter 2]
\medskip\\
The internal workings of MKPCs, in general, make use of a public key consisting of various nonlinear multivariate quadratic, MQ, polynomials defined over some finite field. According to the security level chosen for Rainbow the field sizes adjust, meaning that the variants of Rainbow are 
\begin{itemize}
    \item Level I security: Defined over $GF(16)$
    \item Level III security: Defined over $GF(256)$
    \item Level V security: Defined over $GF(256)$
\end{itemize}
with $GF$ being a Galois field, in this case $GF(2^q)$ with $q = 4$ or $q=8$. The above security levels encapsulate one or more of the NIST-specified security levels (I, II, III, IV, V). In addition to having three security levels, the rainbow scheme also has three variations. These variations correspond to the way the algorithm handles keys, to provide smaller key sizes sacrificing speed in some cases. [NIST rainbow round 3 paper]\medskip\\
As was earlier noted, the keys of Rainbow consist of maps. Specifically, with $n$ variables and $m$ equations, the public key is a mapping $\mathbb{F}_q^n \rightarrow \mathbb{F}_q^m$. The \textit{public key} $P = S \circ F \circ T$ is the composition of three maps. The maps $S$ and $T$ are affine invertible maps used to hide the structure of the central map $F$. The central map $F$ is an invertible map consisting of $m$ multivariate polynomials in $n$ variables. These polynomials are given over various layers of the Oil and Vinegar scheme, also called the \textit{Rainbow layers}. The \textit{secret key} consist of $S$, $F$ and $T$ indivudally.[Multivariate public key cryptosystem chapter 5]\medskip\\
To compute and verify signatures using Rainbow, the maps are used in different ways.
For \textit{signature generation}, the algorithm uses the invertibility of the three maps of the secret key and a hash function to generate signatures. In broad terms, the signature generation scheme uses the hashed document, say $\mathbf{w}$, as input into $\mathbf{x} = S^{-1}(\mathbf{w}), \mathbf{y} = F^{-1}(\mathbf{x}), \mathbf{z} = T^{-1}(\mathbf{y})$, with $F^{-1}(\mathbf{x})$ being some suitable pre-image of $\mathbf{x}$ under $F$. The \textit{signature verification} scheme is quite simpler, as it for some hash function $H$, document $d$, and public key $P$ checks if $P(z) = H(d)$ which has to hold for it to accept.[Multivariate public key cryptosystem chapter 5]

\subsection{The RISC-V ISA} \label{pre-riscv}
Architectures in modern computing fall in to one of two categories, Reduced Instruction Set Computers (RISC) or Complex Instruction Set Computers (CISC). A RISC machine seeks to reduce on the complex nature of certain aspects of CISC machines, as CISC machines have been growing in complexity following the rise of high-level langauges like Java, Python, etc. RISC architectures are typically optimized with regard to register use (either through the compiler or through having an adequate amount of actual hardware registers), instruction pipelines, and having small and fewer instructions (compared to Complex Instruction Set Computer architecture). The optimizations mentioned above came about as multiple studies showed operand referencing, conditional branches, procedure calls and predictable, and small, instruction costs were of importance when looking at how high-level languages interacted with low-level assembly and machine code. [William Stallings, chapter 15] \medskip\\
One such RISC architecture is the RISC-V architecture. RISC-V is an open standard and as such can be freely implemented for different kinds of usage. Any RISC-V implementation is supposed to be some combination of the base RISC-V ISA, which is limited but still usable for many general purposes, and optional extensions providing features like atomic instructions, multiplication and division, floating point support and more. A subset of the extensions and their base ISAs can be seen in [RISC-V Offers Simple, Modular ISA] or [Design of the RISC-V Instruction Set Architecture].
\medskip\\
For this project, the processor used for benchmarking is a VexRiscV-based platform called PQVexRiscV simulated, on a logical level, on a host machine running a Ryzen 7 5800X. Simulating on a logical level, in contrast to a functional level, has the benefit that cycle counts are accurate and therefore can be used for benchmarking as well. The CPU being simulated will be ran with \texttt{512kB} of RAM and equivalently for ROM. The CPU is openly available and was originally created for the \texttt{pqriscv} project, the RISC-V counterpart to the \texttt{pqm4} library [PQVexRiscV reference]. The VexRiscV CPU in general is an RV32IM instruction set CPU, meaning that it has the 32-bit integer base ISA with the multiplication and division extensions, running a five stage pipeline (fetch, decode, execute, memory, writeback). The VexRiscV CPU is optimized for FPGA use [VexRiscV docs] and as such is interesting with regard to embedded or industrial use (for now at least). Other than usage of the PQVexRiscV CPU this project is not affiliated with the \texttt{pqriscv} project nor the \texttt{VexRiscV} project. Although some newer in-progress extensions for RISC-V might be in the works, this project will be working from the RV32IM instruction set used by the VexRiscV CPU by default.\medskip\\