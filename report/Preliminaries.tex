\section{Preliminaries}
\subsection{The Rainbow scheme}
Rainbow is a multivariate public key cryptosystem (MKPC) and can be seen as a multi layered version of the Unbalanced Oil and Vinegar scheme [NIST rainbow round 3 paper]. Rainbow is a potential candidate in round three of the NIST post-quantum standardization for signature schemes. Many MKPCs make use of the NP-hardness of the MQ problem to provide security. [NIST rainbow round 3 paper]
\medskip\\
The keys in Rainbow consists of systems of different kinds of maps. The private key holds a system, $F$, of quadratic polynomials which is then composed with two affine invertible maps, $S$ and $T$, that are supposed to hide the structure of $F$. The public key, $P$, of the system is then $P = S \circ F \circ T$. The multivariate polynomials of Rainbow are defined over different finite fields, according to which security level is chosen. In this project, security level \textit{I} is used and the polynomials are therefore defined over the values of $GF(2^4)$.[NIST rainbow round 3 paper, Multivariate public key cryptosystem chapter 2]
\medskip\\
Signature generation in rainbow is done by using the maps inverted maps of the private key and computing in a \textit{chain-like} way where the next result relies on the previous. For verifying a signature one simply has to compute the hash of the document (of course, using the same hashing function as the signer), compute the output of $P(\textbf{z})$, the public key with the signature as input, and check if the two values are equal. [NIST rainbow round 3 paper]

\subsection{The RISC-V ISA}
RISC (Reduced Instruction Set Computer) architectures are typically optimized with regard to register use (either through the compiler or through actual hardware registers), instruction pipelines, and having small and fewer instructions (compared to CISC machines).\medskip\\
One such RISC architecture is the RISC-V architecture. The RISC-V architecture is an open standard and as such can be freely implemented for different kinds of usage. Any RISC-V implementation is supposed to be some combination of the base RISC-V ISA, which is limited but still usable for many general purposes, and optional extensions providing features like atomic instructions, multiplication and division, floating point support and more. A subset of the extensions and their base ISAs can be seen in [RISC-V Offers Simple, Modular ISA] or [Design of the RISC-V Instruction Set Architecture].
\medskip\\
For this project, the processor used for benchmarking is a VexRiscV-based platform called PQVexRiscV simulated on a host machine running a Ryzen 7 5800X. The CPU is openly available and was originally created for, the RISC-V counterpart to the pqm4 library, pqriscv [PQVexRiscV reference]. The VexRiscV CPU in general is an RV32IM instruction set CPU (32-bit integer base ISA with the multiplication and division extension) running a five stage pipeline (fetch, decode, execute, memory, writeback). The VexRiscV CPU is optimized for FPGA use [VexRiscV docs] and as such is interesting with regard to embedded or industrial use (for now at least). Other than usage of the PQVexRiscV CPU, this project is not affiliated with the pqriscv project nor the VexRiscV project.