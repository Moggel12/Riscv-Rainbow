\section{Preliminaries}
\subsection{The Rainbow scheme}
The Rainbow cryptographic scheme is a multivariate public key cryptosystem (MKPC) that stands as a round 3 candidate in the NIST post-quantum standardization for signature schemes. Being a multivariate cryptosystem, a central aspect of Rainbow is the $NP$-completeness of solving multivariate polynomial systems, or more specifically the $MQ$ problem which is a subcase with all polynomials being degree 2 [Multivariate public key cryptosystem chapter 2]
\medskip\\
The internal workings of multivariate public key cryptosystems, in general, make use of a public key consisting of various nonlinear multivariate polynomials defined over some finite field. According to the security level chosen for Rainbow the field sizes adjust, meaning that the variants of Rainbow are 
\begin{itemize}
    \item Level I security: Defined over $GF(16)$
    \item Level III security: Defined over $GF(256)$
    \item Level V security: Defined over $GF(256)$
\end{itemize}
with $GF$ being a Galois field, in this case $GF(2^q)$ with $q = 4$ or $q=8$. The above security levels encapsulate one or more of the NIST-specified security levels (I, II, III, IV, V). In addition to having three security levels, the rainbow scheme also has three variations. These variations correspond to the way the algorithm handles keys, to provide smaller key sizes sacrificing speed in some cases. [NIST rainbow round 3 paper]\medskip\\
As was earlier noted, the keys of Rainbow consist of maps. Specifically, with $n$ variables and $m$ equations, the public key is a mapping $\mathbb{F}_q^n \rightarrow \mathbb{F}_q^m$. The public key $P = S \circ F \circ T$ is the composition of three maps. The maps $S$ and $T$ are affine invertible maps used to hide the structure of the central map $F$. The central map $F$ is an invertible map consisting of $m$ multivariate polynomials in $n$ variables. These polynomials are given over various layers of the Oil and Vinegar scheme, also called the \textit{Rainbow layers}. The secret key is the three maps individually (non-composed).[Multivariate public key cryptosystem chapter 5]\medskip\\
To compute and verify signatures using Rainbow, the maps are used in different ways.
For \textit{signature generation}, the algorithm uses the invertibility of the three maps of the secret key and a hash function to generate signatures. In broad terms, the signature generation scheme uses the hashed document, say $\mathbf{w}$, as input into $\mathbf{x} = S^{-1}(\mathbf{w}), \mathbf{y} = F^{-1}(\mathbf{x}), \mathbf{z} = T^{-1}(\mathbf{y})$, with $F^{-1}(\mathbf{x})$ being some suitable pre-image of $\mathbf{x}$ under $F$. The \textit{signature verification} scheme is quite simpler, as it for some hash function $H$, document $d$, and public key $P$ checks if $P(z) = H(d)$ which has to hold for it to accept.[Multivariate public key cryptosystem chapter 5]

\subsection{The RISC-V ISA} \label{pre-riscv}
RISC, or Reduced Instruction Set Computer, architectures are typically optimized with regard to register use (either through the compiler or through having an adequate amount of actual hardware registers), instruction pipelines, and having small and fewer instructions (compared to CISC machines). This idea of designing architectures for CPUs came about through several studies, looking at the implications of having CISC (Complex Instruction Set Computer) architectures mimic many of the operations of high-level languages. The optimizations mentioned above came about as multiple studies showed operand referencing, conditional branches, procedure calls and predictable, and small, instruction costs were of importance when looking at how high-level languages interacted with low-level assembly and machine code. [William Stallings, chapter 15] \medskip\\
One such RISC architecture is the RISC-V architecture. RISC-V is an open standard and as such can be freely implemented for different kinds of usage. Any RISC-V implementation is supposed to be some combination of the base RISC-V ISA, which is limited but still usable for many general purposes, and optional extensions providing features like atomic instructions, multiplication and division, floating point support and more. A subset of the extensions and their base ISAs can be seen in [RISC-V Offers Simple, Modular ISA] or [Design of the RISC-V Instruction Set Architecture].
\medskip\\
For this project, the processor used for benchmarking is a VexRiscV-based platform called PQVexRiscV simulated on a host machine running a Ryzen 7 5800X. The CPU being simulated will be ran with \texttt{512 kb} of RAM and equivalently for ROM. The CPU is openly available and was originally created for the \texttt{pqriscv} project, the RISC-V counterpart to the \texttt{pqm4} library [PQVexRiscV reference]. The VexRiscV CPU in general is an RV32IM instruction set CPU, meaning that it has the 32-bit integer base ISA with the multiplication and division extensions, running a five stage pipeline (fetch, decode, execute, memory, writeback). The VexRiscV CPU is optimized for FPGA use [VexRiscV docs] and as such is interesting with regard to embedded or industrial use (for now at least). Other than usage of the PQVexRiscV CPU this project is not affiliated with the \texttt{pqriscv} project nor the \texttt{VexRiscV} project. Although some newer in-progress extensions for RISC-V might be in the works, this project will be working from the RV32IM instruction set used by the VexRiscV CPU by default.\medskip\\